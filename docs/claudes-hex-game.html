<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Claude's hex game</title>
    <script src="https://cdn.rawgit.com/konvajs/konva/2.1.6/konva.min.js"></script>
    <style>
body {
	margin: 0;
	padding: 0;
	overflow: hidden;
	background-color: #F0F0F0;
	text-align: center;
}

.red {background-color: red;}
.green {background-color: green;}
.blue {background-color: blue;}
.yellow {background-color: yellow;}
.black {background-color: black;}

div.header {}
.col {float:left; width: 49%; margin:0;}
.col img {width: 100%;}
div.footer {clear:both}

#container {border: 1px solid green; margin: 5px;}

div.solver { margin: 10px; }
div.solver p { display: inline;}

    </style>
</head>
<body id='body'>

<div class="header">
    <h1>Claude's hex game</h1>
</div>

<div class="col">
	<a href="images/hex.jpg">
     <img src="images/hex.jpg" alt="The physical game: 10 hexagonal pieces" title="The physical game: 10 hexagonal pieces">
	</a>
</div>
<div class="col">

<p class="instructions">
Translate and rotate the pieces. Colored paths form as the pieces touch each other. Can you make 3 continuous paths: red, blue, yellow ?
</p>


<div class="solver">
    <p>Iterations: <span id="iterations"/></span></p>
    <p>State: <span id="stateDisplay"/></span></p>
    <p>Compute time: <span id="ctime"/></span>ns.</p>
    <button onclick="start();">Start</button>
    <button onclick="stop();">Stop</button>
    <label><input name="speedRadioSlow" id="speedRadioSlow" type="radio" value="slow">slow</label>
    <label><input name="speedRadioSlow" type="radio" value="fast" checked="checked">fast</label>
</div>

<div id="container"></div>

<div class="footer">
	<div>
	<a href="http://validator.w3.org/check?uri=referer">Valid HTML 5</a>
	<a href="http://jigsaw.w3.org/css-validator/check/referer">Valid CSS</a>
	</div>
</div>

</div>

<script>

// ============= DRAW PIECES ============= //

function createHexagon (x,y,radius){
   var hexagon = new Konva.RegularPolygon({
      x: x,
      y: y,
      sides: 6,
      radius: radius,
      fill: 'black'
    });
  return hexagon;
}

function createLine (x, y, radius, sides, color_value, color_name) {

    var pos1=0; while(sides[pos1] != color_value) pos1++;
    var pos2=5; while(sides[pos2] != color_value) pos2--;

  var radius5 = radius *5/6;
  var a = Math.cos(pos1 * Math.PI/3) * radius5 ,
      b = Math.sin(pos1 * Math.PI/3) * radius5,
      c = Math.cos(pos2 * Math.PI/3) * radius5,
      d = Math.sin(pos2 * Math.PI/3) * radius5;

    var xM = x + 3*(a+c)/8 , yM = y + 3*(b+d)/8;
    var line = new Konva.Line({
        points: [x+a,y+b, xM,yM, x+c,y+d],
        stroke: color_name,
        strokeWidth: 10,
//        lineCap: 'round',
//        lineJoin: 'round',
        tension : 0.5
    });

  return line;
}

function createPiece (hexData){

    var x = PIECE_RADIUS * (Math.floor(hexData.i / 2)* 2 + 1.1 ),
        y = PIECE_RADIUS * ((hexData.i % 2)*3 + 1.5);
    // x=0,y=0;

    var group = new Konva.Group({
        draggable: true,
		  offsetX: x,
		  offsetY: y,
    });


    var hexagon = createHexagon(x,y,PIECE_RADIUS);
    group.add(hexagon);

    var line;

    line = createLine(x,y, PIECE_RADIUS, hexData.sides, YELLOW, colors[YELLOW]);
    group.add(line);

    line = createLine(x,y, PIECE_RADIUS, hexData.sides, BLUE, colors[BLUE]);
    group.add(line);

    line = createLine(x,y, PIECE_RADIUS, hexData.sides, RED, colors[RED]);
    group.add(line);

    group.on('mouseover', function() {
        document.body.style.cursor = 'pointer';
    });
    group.on('mouseout', function() {
        document.body.style.cursor = 'default';
    });
    group.on('dblclick', function() {
        rotate(group, 1);
        shapesLayer.draw();
    });

   rotate(group, hexData.rotation);

	return group;
}

// ============= GAME CONSTANTS ============= //

var PIECE_RADIUS = 65;
var colors = ['yellow', 'blue', 'red'];
var YELLOW = 0, BLUE=1, RED = 2;

var arr = [];
arr.push( [YELLOW, BLUE, BLUE, RED, YELLOW, RED] );
arr.push( [RED, BLUE, YELLOW, RED, YELLOW, BLUE] );

arr.push( [BLUE, YELLOW, RED, YELLOW, RED, BLUE] );
arr.push( [YELLOW, RED, RED, BLUE, BLUE, YELLOW] );
arr.push( [BLUE, YELLOW, YELLOW, RED, BLUE, RED] );

arr.push( [BLUE, BLUE, RED, YELLOW, YELLOW, RED] );
arr.push( [YELLOW, BLUE, RED, BLUE, RED, YELLOW] );
arr.push( [BLUE, RED, YELLOW, BLUE, YELLOW, RED] );

arr.push( [BLUE, RED, YELLOW, RED, BLUE, YELLOW] );
arr.push( [BLUE, YELLOW, YELLOW, BLUE, RED, RED] );


// ============= CANVAS AND ADD PIECES ============= //

    var width = window.innerWidth / 2;
    var height = window.innerHeight * 3/5;

    var stage = new Konva.Stage({
        container: 'container',
        width: width,
        height: height
    });

    var shapesLayer = new Konva.Layer();

    var pieces = [];

function int_random(excludedMaxInt){
    return Math.floor(Math.random() * excludedMaxInt);
}

    for(var i = arr.length -1; i >=0; i--) {
        var element = arr.splice(int_random(arr.length), 1)[0]; // random piece shuffle
        for (var r=int_random(element.length); r>=0; r--) {
            // random piece rotation
            element.unshift(element.pop());
        }
        var random_rotation = int_random(6);
        pieces[i] = createPiece({i:i, sides: element, rotation: random_rotation});
        shapesLayer.add(pieces[i]);
    }

    stage.add(shapesLayer);


// ================ solver ================

function check(){ return true; }

var speedRadioSlow = document.getElementById("speedRadioSlow");
var stateDisplay = document.getElementById("stateDisplay");


function rotate(piece, nb_sixth_of_circle) {
    piece.rotate(nb_sixth_of_circle * 60);
}

function moveTo(piece, x1, y1) {
    console.log("Moving to " + x1 + "," + y1);
    return function (frame) {
    // console.log(frame);
    // var dx = frame.timeDiff/1000 ;// 1px / second

        var x0 = piece.getX();
        var y0 = piece.getY();

        var dx = (x0 < x1 ? -1 : x1 == x0 ? 0 : 1);
        var dy = (y0 < y1 ? -1 : y1 == y0 ? 0 : 1);
        if (speedRadioSlow.checked) {
            x0 -= dx;
            y0 -= dy;
        } else {
            x0 = x1;
            y0 = y1;
        }
        piece.setX (Math.floor(x0));
        piece.setY (Math.floor(y0));

        if (dx == 0 && dy ==0) {
            stop();
            start();
        }
        return true;
    }
}

var state;

var placed = [], unplaced;

var grid = [
{x:Math.floor(3*PIECE_RADIUS),    y:Math.floor(PIECE_RADIUS)},
{x:Math.floor(5*PIECE_RADIUS),    y:Math.floor(PIECE_RADIUS)},
{x:Math.floor(7*PIECE_RADIUS),    y:Math.floor(PIECE_RADIUS)},
{x:Math.floor(2*PIECE_RADIUS),  y:Math.floor(2.5*PIECE_RADIUS)},
{x:Math.floor(4*PIECE_RADIUS),  y:Math.floor(2.5*PIECE_RADIUS)},
{x:Math.floor(6*PIECE_RADIUS),  y:Math.floor(2.5*PIECE_RADIUS)},
{x:Math.floor(8*PIECE_RADIUS),  y:Math.floor(2.5*PIECE_RADIUS)},
{x:Math.floor(3*PIECE_RADIUS),    y:Math.floor(4*PIECE_RADIUS)},
{x:Math.floor(5*PIECE_RADIUS),    y:Math.floor(4*PIECE_RADIUS)},
{x:Math.floor(7*PIECE_RADIUS),    y:Math.floor(4*PIECE_RADIUS)}
]
; 
function getNextAnimation(){
    var piece;
    console.log("getNextAnimation");
    if (state=='ordering') {
		 for (var i=0; i<pieces.length; i++) {
		     piece = pieces[i];
		     console.log("Piece " +i + "@" + piece.getX() +","+piece.getY());
		     // var x1 = Math.floor(PIECE_RADIUS + PIECE_RADIUS * 2.5 *(i%4));
		     // var y1 = Math.floor(PIECE_RADIUS + PIECE_RADIUS * 2.1 * Math.floor(i/4));
		     var x1 = Math.floor(PIECE_RADIUS);
		     var y1 = Math.floor(PIECE_RADIUS + PIECE_RADIUS / 4 * i);
		     if (piece.getX() != x1 || piece.getY() != y1)
		         return new Konva.Animation(moveTo(piece, x1, y1), shapesLayer);
		 }
		 setState('setting');
		 unplaced = pieces.slice(0); // array copy
		 placed = [];
    }
    if (state=='setting') {
		if (unplaced.length > 0) {
		 piece = unplaced.pop();
       var newPos = grid[placed.length];
       // may want to check here if moving is alright...
       placed.push(piece);
       setState('setting');
		 return new Konva.Animation(moveTo(piece, newPos.x, newPos.y), shapesLayer);
      }
		setState('all_set');
    }
    return null;
}

function start(){
    anim = getNextAnimation();
    if (anim != null)
        anim.start();
}

function stop(){
    if (anim != null)
        anim.stop();
}

var anim ;

var board = [];

function autoSolve() {

    var target = [];

    var currentArr = 0;
    var currentTarget = 0;
    var currentAngle = 0;

    target[currentTarget] = [arr[currentArr], currentAngle];
    if (check(target)){
        // combines, add new piece !
        currentArr++;
        currentTarget++;
        currentAngle = 0;
    } else {
        if (currentAngle < 5) {
            // broke sequence, can rotate
            currentAngle ++;
        } else {
            // broke sequence, can't rotate, so remove
            currentArr--;
            currentTarget++;
        }
    }
}

function setState(newState){
  state = newState;
  stateDisplay.innerHTML = state + '('+placed.length +')'; 
}

setState('ordering')
start();

</script>

</body>
</html>

